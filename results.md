# results

## Algorithms

### Breadth-First Search: 
Breadth-first search was implemented as a tree-generating algorithm. This tree is in the format of a vector of vectors of size_t objects, and the ith position in the vector corresponds to the vector of NodeID’s of the children of the node with NodeID i. It can accept either a NodeID, which corresponds to a RoadNode, or a pair of doubles, which we use a KDTree to find the closest RoadNode in the network. This RoadNode is then used as the starting vertex of the algorithm. To test this algorithm, we created a sample graph and ran the BFS algorithm on it. The visualization of this can be found by clicking [Link 1](https://drive.google.com/file/d/179ORcitslhhS-mjhf0qYDIQS61dykQoq/view?usp=sharing). Note that the starting point of the BFS is the vertex just to the right of the vertex in the bottom-left corner. We can see that the bottom-left corner is colored red, even though it is not connected to any other vertex, indicating that the algorithm works on disconnected graphs. We also have linked the BFS algorithm’s output for all of Illinois, starting in front of ISR, at [Link 2](https://drive.google.com/file/d/18xLSCuBxN1gnbUnq_wSPCfKOIrNNUk9d/view?usp=sharing). You will notice that almost all the roads are red. This is likely due to RoadNode being spaced relatively close together, so even if a single road is very long, that whole road is not a single RoadEdge, so the BFS would return a tree that grows mostly circularly outward from ISR, leading to a mostly red graph in all but the cities.

### Dijkstra’s algorithm: 
Dijkstra’s algorithm was implemented in the traditional way. It accepts either two NodeID’s, which corrospond directly to RoadNodes, or two pairs of doubles, which we use a KDTree to find the closet RoadNodes. These represent the start and end vertices, respectively. The algorithm returns a vector of size_t’s storing the NodeID’s of the safest path between the start and end node. The function DijkstraTree, computes the crash probabilities and safest paths beginning with the start RoadNode and terminating when the end RoadNode is on the top of the min probability priority queue. It returns a pair of vectors, one storing doubles, which represent crash probabilities, and the other storing size_t’s, which represent NodeID’s. This second vector stores the safest paths between seen nodes and the starting node. It is used in the Dijkstra function to construct the path between the end and start nodes. To test the algorithm, we created a sample graph and ran a short and long Dijkstra’s algorithm on it, which can be seen at [Link 3](https://drive.google.com/file/d/1uIubVL9TusdwZ8z0_-K-bAwdzPxpxMJ5/view?usp=sharing) and [Link 4](https://drive.google.com/file/d/1Rghzg3yd3zlwRmsBqU3q8gEuETUMkRNt/view?usp=sharing). Note that since the graph is undirected, either vertices at the ends of the path can be thought of as the start or end nodes. We also have linked the Dijkstra’s algorithm output for a route between ISR and the Willis Tower. Notice how we have two files for this. The old one ([Link 5](https://drive.google.com/file/d/102W-ou5CvMfoelPKzy-VvB86blnY56wy/view?usp=sharing)) calculates the true safest path, while the new one ([Link 6](https://drive.google.com/file/d/1v_qOF7Tuw6afwxGmFpNAqjGrYvzP9FRp/view?usp=sharing)) calculates an adjusted safest path that gives a penalty to long distance routes. This is done in order to create a more practical driving route. Even so, both paths, especially the first, takes many rural roads, which indicate that rural, likely low-traffic, roads are very safe.

### Visualization:
Our visualization algorithm is built on top of a dynamic array of integers holding RGB values for each pixel. This Image class wraps around this object so it can be easily used with functions such as getPixel and setPixel. The RoadImage class utilizes the Image class and draws paths using lists of coordinates of longitude and latitude with the addPath function. These coordinates are first transformed to fit the image dimensions and then connected using simple point slope form and consideration of the row/column difference. The Image class contains a toPPM function that creates a PPM file. Alternatively, for a much faster output, the Image class also contains the toPNG function, which has its underlying implementation in lodepng. For our visualization output, we use a white map and overlay black roads on it. After finding an algorithm’s out, we overlay a bold, red path on top of the map. Examples of the visualization can be seen in all links, but [Link 7](https://drive.google.com/file/d/1HC-IpaAKhy6hzz-tXW8H3U0UGDceywya/view?usp=share_link) and [Link 8](https://drive.google.com/file/d/1_pdFwI6b96Js0MYQMIr2S0ts1p1OIN2c/view?usp=share_link) are the visualizations specifically for this algorithm.

## Conclusion

In the end, we were able to achieve our goal of finding the safest route between any two points in Illinois. However, we realized that such a route can often be quite long and inconvenient. As such, we ended up choosing to penalize longer routes while still finding a reasonable balance between safety and distance. We believe that this tool has a lot of societal applications and could be used by governments, road service agencies, and regular individuals. While this tool does have a lot of monetary potential, we believe that the strongest point of our tool is its potential ability to save lives. For instance, using the results of this application to create GPS apps that consider both time and safety could help millions. Furthermore, though we initially designed this tool for our dataset, the tool could be readily applied to other datasets or modified to solve similar problems (like finding a path between two points with the least traffic.) Ultimately, getting to work together on a complex program that solves a real problem was something that we all enjoyed and learned a lot from.

Link 1: [https://drive.google.com/file/d/179ORcitslhhS-mjhf0qYDIQS61dykQoq/view?usp=sharing](https://drive.google.com/file/d/179ORcitslhhS-mjhf0qYDIQS61dykQoq/view?usp=sharing)

Link 2: [https://drive.google.com/file/d/18xLSCuBxN1gnbUnq_wSPCfKOIrNNUk9d/view?usp=sharing](https://drive.google.com/file/d/18xLSCuBxN1gnbUnq_wSPCfKOIrNNUk9d/view?usp=sharing)

Link 3: [https://drive.google.com/file/d/1uIubVL9TusdwZ8z0_-K-bAwdzPxpxMJ5/view?usp=sharing](https://drive.google.com/file/d/1uIubVL9TusdwZ8z0_-K-bAwdzPxpxMJ5/view?usp=sharing)

Link 4: [https://drive.google.com/file/d/1Rghzg3yd3zlwRmsBqU3q8gEuETUMkRNt/view?usp=sharing](https://drive.google.com/file/d/1Rghzg3yd3zlwRmsBqU3q8gEuETUMkRNt/view?usp=sharing)

Link 5: [https://drive.google.com/file/d/102W-ou5CvMfoelPKzy-VvB86blnY56wy/view?usp=sharing](https://drive.google.com/file/d/102W-ou5CvMfoelPKzy-VvB86blnY56wy/view?usp=sharing)

Link 6: [https://drive.google.com/file/d/1v_qOF7Tuw6afwxGmFpNAqjGrYvzP9FRp/view?usp=sharing](https://drive.google.com/file/d/1v_qOF7Tuw6afwxGmFpNAqjGrYvzP9FRp/view?usp=sharing)

Link 7: [https://drive.google.com/file/d/1HC-IpaAKhy6hzz-tXW8H3U0UGDceywya/view?usp=share_link](https://drive.google.com/file/d/1HC-IpaAKhy6hzz-tXW8H3U0UGDceywya/view?usp=share_link)

Link 8: [https://drive.google.com/file/d/1_pdFwI6b96Js0MYQMIr2S0ts1p1OIN2c/view?usp=share_link](https://drive.google.com/file/d/1_pdFwI6b96Js0MYQMIr2S0ts1p1OIN2c/view?usp=share_link)
